
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/asliddinberdiev/medium_clone/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/asliddinberdiev/medium_clone/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/asliddinberdiev/medium_clone/docs/docs.go (0.0%)</option>
				
				<option value="file3">github.com/asliddinberdiev/medium_clone/handler/handler_auth.go (0.0%)</option>
				
				<option value="file4">github.com/asliddinberdiev/medium_clone/handler/handler_post.go (0.0%)</option>
				
				<option value="file5">github.com/asliddinberdiev/medium_clone/handler/handler_user.go (0.0%)</option>
				
				<option value="file6">github.com/asliddinberdiev/medium_clone/handler/router.go (0.0%)</option>
				
				<option value="file7">github.com/asliddinberdiev/medium_clone/middleware/auth.go (0.0%)</option>
				
				<option value="file8">github.com/asliddinberdiev/medium_clone/models/auth.go (0.0%)</option>
				
				<option value="file9">github.com/asliddinberdiev/medium_clone/models/models.go (100.0%)</option>
				
				<option value="file10">github.com/asliddinberdiev/medium_clone/models/user.go (0.0%)</option>
				
				<option value="file11">github.com/asliddinberdiev/medium_clone/repository/postgres.go (81.8%)</option>
				
				<option value="file12">github.com/asliddinberdiev/medium_clone/repository/redis.go (100.0%)</option>
				
				<option value="file13">github.com/asliddinberdiev/medium_clone/repository/repo_auth.go (100.0%)</option>
				
				<option value="file14">github.com/asliddinberdiev/medium_clone/repository/repo_user.go (100.0%)</option>
				
				<option value="file15">github.com/asliddinberdiev/medium_clone/repository/repository.go (100.0%)</option>
				
				<option value="file16">github.com/asliddinberdiev/medium_clone/server/server.go (0.0%)</option>
				
				<option value="file17">github.com/asliddinberdiev/medium_clone/service/service.go (0.0%)</option>
				
				<option value="file18">github.com/asliddinberdiev/medium_clone/service/service_auth.go (0.0%)</option>
				
				<option value="file19">github.com/asliddinberdiev/medium_clone/service/service_log.go (0.0%)</option>
				
				<option value="file20">github.com/asliddinberdiev/medium_clone/service/service_token.go (0.0%)</option>
				
				<option value="file21">github.com/asliddinberdiev/medium_clone/service/service_user.go (0.0%)</option>
				
				<option value="file22">github.com/asliddinberdiev/medium_clone/utils/http.go (0.0%)</option>
				
				<option value="file23">github.com/asliddinberdiev/medium_clone/utils/password.go (0.0%)</option>
				
				<option value="file24">github.com/asliddinberdiev/medium_clone/utils/string.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "os"
        "path"

        "github.com/asliddinberdiev/medium_clone/config"
        "github.com/asliddinberdiev/medium_clone/handler"
        "github.com/asliddinberdiev/medium_clone/repository"
        "github.com/asliddinberdiev/medium_clone/server"
        "github.com/asliddinberdiev/medium_clone/service"

        _ "github.com/lib/pq"
)


// @title MEDIUM MINI_API
// @version 1.0
// @description API Server for MEDIUM_MINI Application

// @contact.name Asliddin
// @contact.url https://agsu.uz
// @contact.email asliddinberdiyevv@gmail.com

// @host localhost:8000
// @BasePath /
// @schemes http https

// @securityDefinitions.apiKey ApiKeyAuth
// @in header
// @name Authorization
func main() <span class="cov0" title="0">{
        _ = os.Mkdir("logs", 0770)
        logFile, err := os.OpenFile(path.Join("logs", "app.log"), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("create log file error: ", err)
        }</span>
        <span class="cov0" title="0">log.SetOutput(logFile)

        cfg := config.Load(".")

        db, err := repository.NewPostgresDB(repository.PostgresConfig{
                User:     cfg.Postgres.User,
                Password: cfg.Postgres.Password,
                Host:     cfg.Postgres.Host,
                Port:     cfg.Postgres.Port,
                Database: cfg.Postgres.Database,
                SSLMode:  cfg.Postgres.SSLMode,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("failed to initialize db error: ", err)
        }</span>

        // initialize rdb
        <span class="cov0" title="0">rdb, err := repository.NewRedisDB(repository.RedisConfig{
                Host:     cfg.Redis.Host,
                Password: cfg.Redis.Password,
                Port:     cfg.Redis.Port,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("failed to initialize rsdb error: ", err)
        }</span>

        <span class="cov0" title="0">repos := repository.NewRepository(db, rdb)
        services := service.NewService(repos, cfg.App)
        handlers := handler.NewHandler(services, cfg.App)

        log.Println("app run on port: ", cfg.App.Port)
        srv := new(server.Server)
        if err := srv.Run(cfg.App.Port, handlers.InitRoutes()); err != nil </span><span class="cov0" title="0">{
                log.Fatalln("running http server error: ", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "log"

        "github.com/joho/godotenv"
        "github.com/spf13/viper"
)

type Config struct {
        App      App
        Postgres Postgres
        Redis    Redis
}

type App struct {
        Port        string
        Version     string
        TokenKey    string
        AccessTime  string
        RefreshTime string
}

type Postgres struct {
        Host     string
        Port     string
        User     string
        Password string
        Database string
        SSLMode  string
}

type Redis struct {
        Host     string
        Port     string
        Password string
}

func Load(path string) Config <span class="cov0" title="0">{
        err := godotenv.Load(path + "/.env")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln("loading .env file error: ", err)
        }</span>

        <span class="cov0" title="0">conf := viper.New()
        conf.AutomaticEnv()

        cfg := Config{
                App: App{
                        Port:        conf.GetString("APP_PORT"),
                        Version:     conf.GetString("APP_VERSION"),
                        TokenKey:    conf.GetString("APP_TOKEN_KEY"),
                        AccessTime:  conf.GetString("APP_ACCESS_TIME"),
                        RefreshTime: conf.GetString("APP_REFRESH_TIME"),
                },
                Postgres: Postgres{
                        Host:     conf.GetString("POSTGRES_HOST"),
                        Port:     conf.GetString("POSTGRES_PORT"),
                        User:     conf.GetString("POSTGRES_USER"),
                        Password: conf.GetString("POSTGRES_PASSWORD"),
                        Database: conf.GetString("POSTGRES_DB"),
                        SSLMode:  conf.GetString("POSTGRES_SSLMODE"),
                },
                Redis: Redis{
                        Host:     conf.GetString("REDIS_HOST"),
                        Port:     conf.GetString("REDIS_PORT"),
                        Password: conf.GetString("REDIS_PASSWORD"),
                },
        }

        return cfg</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Asliddin",
            "url": "https://agsu.uz",
            "email": "asliddinberdiyevv@gmail.com"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/login": {
            "post": {
                "description": "login a user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Login",
                "parameters": [
                    {
                        "description": "Login Request",
                        "name": "req",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Login"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "logout a user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Logout",
                "parameters": [
                    {
                        "description": "Logout Request",
                        "name": "req",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Token"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "register a user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Register",
                "parameters": [
                    {
                        "description": "Register Request",
                        "name": "req",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UserCreate"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    }
                }
            }
        },
        "/users": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "get all users",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "GetAll",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseList"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    }
                }
            }
        },
        "/users/{id}": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "get by id user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "GetByID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "id",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "update user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Update",
                "parameters": [
                    {
                        "type": "string",
                        "description": "id",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "UpdateUser Request",
                        "name": "req",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdateUser"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "delete user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "users"
                ],
                "summary": "Delete",
                "parameters": [
                    {
                        "type": "string",
                        "description": "id",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Response"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.ResponseStatus"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "models.Login": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "minLength": 6
                }
            }
        },
        "models.Response": {
            "type": "object",
            "properties": {
                "data": {},
                "message": {
                    "type": "string"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "models.ResponseList": {
            "type": "object",
            "properties": {
                "data": {},
                "limit": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "page": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "models.ResponseStatus": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "models.Token": {
            "type": "object",
            "properties": {
                "token": {
                    "type": "string"
                }
            }
        },
        "models.UpdateUser": {
            "type": "object",
            "properties": {
                "first_name": {
                    "type": "string",
                    "minLength": 2
                },
                "last_name": {
                    "type": "string",
                    "minLength": 2
                },
                "role": {
                    "type": "string",
                    "enum": [
                        "admin",
                        "user"
                    ]
                }
            }
        },
        "models.UserCreate": {
            "type": "object",
            "required": [
                "email",
                "first_name",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string",
                    "minLength": 2
                },
                "last_name": {
                    "type": "string",
                    "minLength": 2
                },
                "password": {
                    "type": "string",
                    "minLength": 6
                },
                "role": {
                    "type": "string",
                    "enum": [
                        "admin",
                        "user"
                    ]
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8000",
        BasePath:         "/",
        Schemes:          []string{"http", "https"},
        Title:            "MEDIUM MINI_API",
        Description:      "API Server for MEDIUM_MINI Application",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "database/sql"
        "log"
        "net/http"
        "time"

        "github.com/asliddinberdiev/medium_clone/models"
        "github.com/asliddinberdiev/medium_clone/utils"
        "github.com/gin-gonic/gin"
)

// @Summary      Login
// @Description  login a user
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        req  body      models.Login true "Login Request"
// @Success      200  {object}  models.Response
// @Failure      400  {object}  models.ResponseStatus
// @Failure      500  {object}  models.ResponseStatus
// @Router       /auth/login [post]
func (h *Handler) login(ctx *gin.Context) <span class="cov0" title="0">{
        var input models.Login
        err := ctx.ShouldBindJSON(&amp;input)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "required fields")
                return
        }</span>

        <span class="cov0" title="0">if err := input.IsValid(); err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "fields validation error")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.services.User.GetByEmail(input.Email)
        if err != nil </span><span class="cov0" title="0">{
                if utils.HasStringKey(err.Error(), "duplicate key") </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusBadRequest, "email already used")
                        return
                }</span>
                <span class="cov0" title="0">if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusBadRequest, "email or password wrong")
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return</span>
        }

        <span class="cov0" title="0">if ok := utils.CheckPassword(user.Password, input.Password); !ok </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "email or password wrong")
                return
        }</span>

        <span class="cov0" title="0">accessToken, err := h.services.Token.AccessTokenGenerate(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return
        }</span>

        <span class="cov0" title="0">refreshToken, err := h.services.Token.RefreshTokenGenerate(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return
        }</span>

        <span class="cov0" title="0">token := map[string]string{
                "access":  accessToken,
                "refresh": refreshToken,
        }

        utils.Data(ctx, http.StatusOK, "welcome", map[string]interface{}{
                "token": token,
                "user":  user,
        })</span>
}

// @Summary      Logout
// @Description  logout a user
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        req  body      models.Token true "Logout Request"
// @Success      200  {object}  models.Response
// @Failure      400  {object}  models.ResponseStatus
// @Failure      400  {object}  models.ResponseStatus
// @Failure      401  {object}  models.ResponseStatus
// @Failure      500  {object}  models.ResponseStatus
// @Router       /auth/logout [post]
// @Security ApiKeyAuth
func (h *Handler) logout(ctx *gin.Context) <span class="cov0" title="0">{
        var input models.Token
        err := ctx.ShouldBindJSON(&amp;input)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "required fields")
                return
        }</span>

        <span class="cov0" title="0">if input.Token == "" </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "invalid token 1")
                return
        }</span>

        <span class="cov0" title="0">claims, err := h.services.Token.Parse(input.Token)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return
        }</span>

        <span class="cov0" title="0">tokenID, ok := claims["jti"].(string)
        if !ok </span><span class="cov0" title="0">{
                log.Println("handler_auth: logout - claims  jti type error")
                utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return
        }</span>

        <span class="cov0" title="0">if err := h.services.Auth.AddBlack(tokenID, input.Token, time.Hour*24); err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return
        }</span>

        <span class="cov0" title="0">utils.Status(ctx, http.StatusOK, "see you again :)")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import "github.com/gin-gonic/gin"

func (h *Handler) postCreate(c *gin.Context) {<span class="cov0" title="0">}</span>
func (h *Handler) postGetAll(c *gin.Context) {<span class="cov0" title="0">}</span>
func (h *Handler) postGet(c *gin.Context) {<span class="cov0" title="0">}</span>
func (h *Handler) postUpdate(c *gin.Context) {<span class="cov0" title="0">}</span>
func (h *Handler) postDelete(c *gin.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "database/sql"
        "net/http"
        "reflect"

        models "github.com/asliddinberdiev/medium_clone/models"
        "github.com/asliddinberdiev/medium_clone/utils"
        "github.com/gin-gonic/gin"
)

// @Summary      Register
// @Description  register a user
// @Tags         auth
// @Accept       json
// @Produce      json
// @Param        req  body      models.UserCreate true "Register Request"
// @Success      200  {object}  models.Response
// @Failure      400  {object}  models.ResponseStatus
// @Failure      500  {object}  models.ResponseStatus
// @Router       /auth/register [post]
func (h *Handler) userCreate(ctx *gin.Context) <span class="cov0" title="0">{
        var input models.UserCreate
        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "required fields")
                return
        }</span>

        <span class="cov0" title="0">if err := input.IsValid(); err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "fields validation error")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.services.User.Create(input)
        if err != nil </span><span class="cov0" title="0">{
                if utils.HasStringKey(err.Error(), "duplicate key") </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusBadRequest, "this email already used")
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return</span>
        }

        <span class="cov0" title="0">accessToken, err := h.services.Token.AccessTokenGenerate(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return
        }</span>

        <span class="cov0" title="0">refreshToken, err := h.services.Token.RefreshTokenGenerate(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return
        }</span>

        <span class="cov0" title="0">token := map[string]string{
                "access":  accessToken,
                "refresh": refreshToken,
        }

        utils.Data(ctx, http.StatusCreated, "created successfully", map[string]interface{}{
                "token": token,
                "user":  user,
        })</span>
}

// @Summary      GetAll
// @Description  get all users
// @Tags         users
// @Accept       json
// @Produce      json
// @Success      200  {object}   models.ResponseList
// @Failure      400   {object}  models.ResponseStatus
// @Failure      401   {object}  models.ResponseStatus
// @Failure      403   {object}  models.ResponseStatus
// @Failure      500   {object}  models.ResponseStatus
// @Router       /users [get]
// @Security ApiKeyAuth
func (h *Handler) userGetAll(ctx *gin.Context) <span class="cov0" title="0">{
        list, err := h.services.User.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return
        }</span>

        <span class="cov0" title="0">utils.List(ctx, http.StatusOK, "get all user successfully", 10, 1, list)</span>
}

// @Summary      GetByID
// @Description  get by id user
// @Tags         users
// @Accept       json
// @Produce      json
// @Param                  id path string true "id"
// @Success      200  {object}   models.Response
// @Failure      400   {object}  models.ResponseStatus
// @Failure      401   {object}  models.ResponseStatus
// @Failure      404   {object}  models.ResponseStatus
// @Failure      500   {object}  models.ResponseStatus
// @Router       /users/{id} [get]
// @Security ApiKeyAuth
func (h *Handler) userGetByID(ctx *gin.Context) <span class="cov0" title="0">{
        id, ok := ctx.Params.Get("id")
        if !ok </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "invalid id param")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.services.User.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusNotFound, "user not found")
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return</span>
        }

        <span class="cov0" title="0">utils.Data(ctx, http.StatusOK, "get user successfully", user)</span>
}

// @Summary      Update
// @Description  update user
// @Tags         users
// @Accept       json
// @Produce      json
// @Param                  id path string true "id"
// @Param                  req  body  models.UpdateUser true "UpdateUser Request"
// @Success      200  {object}   models.Response
// @Failure      400   {object}  models.ResponseStatus
// @Failure      401   {object}  models.ResponseStatus
// @Failure      403   {object}  models.ResponseStatus
// @Failure      404   {object}  models.ResponseStatus
// @Failure      500   {object}  models.ResponseStatus
// @Router       /users/{id} [put]
// @Security ApiKeyAuth
func (h *Handler) userUpdate(ctx *gin.Context) <span class="cov0" title="0">{
        var input models.UpdateUser
        if err := ctx.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "required fields")
                return
        }</span>
        <span class="cov0" title="0">if reflect.DeepEqual(input, models.UpdateUser{}) </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "required fields")
                return
        }</span>

        <span class="cov0" title="0">if err := input.IsValid(); err != nil </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "fields validation error")
                return
        }</span>

        <span class="cov0" title="0">id, ok := ctx.Params.Get("id")
        if !ok </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "invalid id param")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.services.User.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusNotFound, "user not found")
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return</span>
        }

        <span class="cov0" title="0">if input.Role != "" &amp;&amp; user.Role != "admin" </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusForbidden, "access denied")
                return
        }</span>

        <span class="cov0" title="0">updateUser, err := h.services.User.Update(id, input)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusNotFound, "user not found")
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return</span>
        }

        <span class="cov0" title="0">utils.Data(ctx, http.StatusOK, "update user successfully", updateUser)</span>
}

// @Summary      Delete
// @Description  delete user
// @Tags         users
// @Accept       json
// @Produce      json
// @Param                  id path string true "id"
// @Success      200  {object}   models.Response
// @Failure      400   {object}  models.ResponseStatus
// @Failure      401   {object}  models.ResponseStatus
// @Failure      404   {object}  models.ResponseStatus
// @Failure      500   {object}  models.ResponseStatus
// @Router       /users/{id} [delete]
// @Security ApiKeyAuth
func (h *Handler) userDelete(ctx *gin.Context) <span class="cov0" title="0">{
        id, ok := ctx.Params.Get("id")
        if !ok </span><span class="cov0" title="0">{
                utils.Error(ctx, http.StatusBadRequest, "invalid id param")
                return
        }</span>

        <span class="cov0" title="0">err := h.services.User.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusNotFound, "user not found")
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                return</span>
        }

        <span class="cov0" title="0">utils.Data(ctx, http.StatusOK, "delete user successfully", map[string]interface{}{
                "id": id,
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "github.com/asliddinberdiev/medium_clone/config"
        "github.com/asliddinberdiev/medium_clone/docs"
        "github.com/asliddinberdiev/medium_clone/middleware"
        "github.com/asliddinberdiev/medium_clone/service"
        "github.com/gin-gonic/gin"
        swaggerfiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

type Handler struct {
        services *service.Service
        cfg      config.App
}

func NewHandler(services *service.Service, cfg config.App) *Handler <span class="cov0" title="0">{
        return &amp;Handler{services: services, cfg: cfg}
}</span>

func (h *Handler) InitRoutes() *gin.Engine <span class="cov0" title="0">{
        router := gin.New()

        router.Use(service.CustomLogger(service.LoggerWrite()))
        router.RedirectTrailingSlash = true

        v1 := router.Group("/api/" + h.cfg.Version)
        </span><span class="cov0" title="0">{
                public := v1.Group("")
                </span><span class="cov0" title="0">{
                        auth := public.Group("/auth")
                        </span><span class="cov0" title="0">{
                                auth.POST("/login", h.login)
                                auth.POST("/register", h.userCreate)
                        }</span>

                        <span class="cov0" title="0">posts := public.Group("/posts")
                        </span><span class="cov0" title="0">{
                                posts.POST("/", h.postCreate)
                                posts.GET("/", h.postGetAll)
                                posts.GET("/:id", h.postGet)
                        }</span>
                }

                <span class="cov0" title="0">private := v1.Group("", middleware.JWTMiddleware(h.services))
                </span><span class="cov0" title="0">{
                        auth := private.Group("/auth")
                        </span><span class="cov0" title="0">{
                                auth.POST("/logout", h.logout)
                        }</span>

                        <span class="cov0" title="0">users := private.Group("/users")
                        </span><span class="cov0" title="0">{
                                users.GET("/", middleware.Admin(h.services), h.userGetAll)
                                users.GET("/:id", h.userGetByID)
                                users.PUT("/:id", h.userUpdate)
                                users.DELETE("/:id", h.userDelete)
                        }</span>

                        <span class="cov0" title="0">posts := private.Group("/posts")
                        </span><span class="cov0" title="0">{
                                posts.PUT("/:id", h.postUpdate)
                                posts.DELETE("/:id", h.postDelete)
                        }</span>
                }
        }

        <span class="cov0" title="0">docs.SwaggerInfo.BasePath = v1.BasePath()
        router.GET("/docs/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))

        return router</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "log"
        "net/http"
        "strings"

        "github.com/asliddinberdiev/medium_clone/service"
        "github.com/asliddinberdiev/medium_clone/utils"
        "github.com/gin-gonic/gin"
)

func JWTMiddleware(services *service.Service) gin.HandlerFunc <span class="cov0" title="0">{
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                authHeader := ctx.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusUnauthorized, "invalid authorization")
                        return
                }</span>

                <span class="cov0" title="0">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 || tokenParts[0] != "Bearer" </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusUnauthorized, "invalid authorization")
                        return
                }</span>

                <span class="cov0" title="0">token := tokenParts[1]
                if token == "" </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusUnauthorized, "invalid authorization")
                        return
                }</span>

                <span class="cov0" title="0">claims, err := services.Token.Parse(token)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusUnauthorized, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">tokenID, ok := claims["jti"].(string)
                if !ok </span><span class="cov0" title="0">{
                        log.Println("middleware: JTI is not a string")
                        utils.Error(ctx, http.StatusUnauthorized, "invalid token")
                        return
                }</span>
                <span class="cov0" title="0">if ok := services.Auth.HasBlackToken(tokenID); !ok </span><span class="cov0" title="0">{
                        log.Println("middleware: JWT is black token")
                        utils.Error(ctx, http.StatusUnauthorized, "invalid token")
                        return
                }</span>

                <span class="cov0" title="0">if claims["type"] != "access" </span><span class="cov0" title="0">{
                        log.Println("middleware: JWT type not access")
                        utils.Error(ctx, http.StatusUnauthorized, "invalid token")
                        return
                }</span>

                <span class="cov0" title="0">ctx.Set("user_id", claims["id"])

                ctx.Next()</span>
        }
}

func Admin(services *service.Service) gin.HandlerFunc <span class="cov0" title="0">{
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                id := ctx.GetString("user_id")

                user, err := services.User.GetByID(id)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusInternalServerError, "we got internal server :(")
                        return
                }</span>

                <span class="cov0" title="0">if user.Role != "admin" </span><span class="cov0" title="0">{
                        utils.Error(ctx, http.StatusForbidden, "access denied")
                        return
                }</span>

                <span class="cov0" title="0">ctx.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

type Login struct {
        Email    string `json:"email" db:"email" validate:"required,email"`
        Password string `json:"password" db:"password" validate:"required,min=6"`
}

type Token struct {
        Token string `json:"token"`
}

func (l *Login) IsValid() error <span class="cov0" title="0">{
        return validate.Struct(l)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package models

import "github.com/go-playground/validator/v10"

var validate *validator.Validate

func init() <span class="cov8" title="1">{
        validate = validator.New()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package models

type User struct {
        ID        string `json:"id" db:"id"`
        FirstName string `json:"first_name" db:"first_name"`
        LastName  string `json:"last_name" db:"last_name"`
        Email     string `json:"email" db:"email"`
        Password  string `json:"-" db:"password"`
        Role      string `json:"role" db:"role"`
        CreatedAt string `json:"created_at" db:"created_at"`
        UpdatedAt string `json:"updated_at" db:"updated_at"`
}

type UserCreate struct {
        FirstName string `json:"first_name" db:"first_name" validate:"required,min=2"`
        LastName  string `json:"last_name" db:"last_name" validate:"omitempty,min=2"`
        Email     string `json:"email" db:"email" validate:"required,email"`
        Password  string `json:"password" db:"password" validate:"required,min=6"`
        Role      string `json:"role" db:"role" validate:"omitempty,oneof=admin user"`
}

type UpdateUser struct {
        FirstName string `json:"first_name" db:"first_name" validate:"omitempty,min=2"`
        LastName  string `json:"last_name" db:"last_name" validate:"omitempty,min=2"`
        Role      string `json:"role" db:"role" validate:"omitempty,oneof=admin user"`
}

func (uc *UserCreate) IsValid() error <span class="cov0" title="0">{
        return validate.Struct(uc)
}</span>

func (uu *UpdateUser) IsValid() error <span class="cov0" title="0">{
        return validate.Struct(uu)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package repository

import (
        "fmt"

        "log"

        "github.com/jmoiron/sqlx"
)

type PostgresConfig struct {
        User     string
        Password string
        Host     string
        Port     string
        Database string
        SSLMode  string
}

func NewPostgresDB(cfg PostgresConfig) (*sqlx.DB, error) <span class="cov8" title="1">{
        dbUrl := fmt.Sprintf("host=%s port=%s user=%s dbname=%s password=%s sslmode=%s",
                cfg.Host,
                cfg.Port,
                cfg.User,
                cfg.Database,
                cfg.Password,
                cfg.SSLMode,
        )

        db, err := sqlx.Open("postgres", dbUrl)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("repository_postgres: open error: ", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = db.Ping()
        if err != nil </span><span class="cov8" title="1">{
                log.Println("repository_postgres: ping error: ", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">log.Println("repository_postgres: initialize")
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package repository

import (
        "context"
        "fmt"

        "log"

        "github.com/redis/go-redis/v9"
)

type RedisConfig struct {
        Host     string
        Port     string
        Password string
}

func NewRedisDB(cfg RedisConfig) (*redis.Client, error) <span class="cov8" title="1">{
        rsUrl := fmt.Sprintf("%s:%s", cfg.Host, cfg.Port)

        rdb := redis.NewClient(&amp;redis.Options{
                Addr:     rsUrl,
                Password: cfg.Password,
        })

        _, err := rdb.Ping(context.Background()).Result()
        if err != nil </span><span class="cov8" title="1">{
                log.Println("repository_redis: NewRedisDB - ping error: ", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">log.Println("repository_redis: initialize")
        return rdb, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package repository

import (
        "context"
        "time"

        "github.com/jmoiron/sqlx"
        "github.com/redis/go-redis/v9"
)

type AuthRepository struct {
        db  *sqlx.DB
        rdb *redis.Client
}

func NewAuthRepository(db *sqlx.DB, rdb *redis.Client) *AuthRepository <span class="cov8" title="1">{
        return &amp;AuthRepository{db: db, rdb: rdb}
}</span>

func (r *AuthRepository) AddBlack(tokenID, token string, exp time.Duration) error <span class="cov8" title="1">{
        ctx := context.Background()
        return r.rdb.Set(ctx, tokenID, token, exp).Err()
}</span>

func (r *AuthRepository) GetBlackToken(tokenID string) (string, error) <span class="cov8" title="1">{
        ctx := context.Background()
        return r.rdb.Get(ctx, tokenID).Result()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package repository

import (
        "log"
        "time"

        models "github.com/asliddinberdiev/medium_clone/models"
        "github.com/jmoiron/sqlx"
)

type UserRepository struct {
        db *sqlx.DB
}

func NewUserRepository(db *sqlx.DB) *UserRepository <span class="cov8" title="1">{
        return &amp;UserRepository{db: db}
}</span>

func (r *UserRepository) Create(user models.User) (*models.User, error) <span class="cov8" title="1">{
        query := `
                INSERT INTO users (id, first_name, last_name, email, password, role) 
                VALUES($1, $2, $3, $4, $5, $6) 
                RETURNING id, first_name, last_name, email, role, created_at, updated_at 
        `

        err := r.db.QueryRow(query, user.ID, user.FirstName, user.LastName, user.Email, user.Password, user.Role).Scan(&amp;user.ID, &amp;user.FirstName, &amp;user.LastName, &amp;user.Email, &amp;user.Role, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("repository_user: create - query error: ", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *UserRepository) GetAll() ([]*models.User, error) <span class="cov8" title="1">{
        var users []*models.User
        query := `
                SELECT 
                        id, first_name, last_name,
                        email, role, created_at, updated_at
                FROM users
        `
        err := r.db.Select(&amp;users, query)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("repository_user: getAll - query error: ", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return users, nil</span>
}

func (r *UserRepository) GetByID(id string) (*models.User, error) <span class="cov8" title="1">{
        query := `
                SELECT 
                        id, first_name, last_name,
                        email, role, created_at, updated_at
                FROM users WHERE id = $1
        `

        var user models.User
        err := r.db.QueryRow(query, id).Scan(&amp;user.ID, &amp;user.FirstName, &amp;user.LastName, &amp;user.Email, &amp;user.Role, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("repository_user: getByID - query error: ", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *UserRepository) GetByEmail(email string) (*models.User, error) <span class="cov8" title="1">{
        query := `
                SELECT 
                        id, first_name, last_name,
                        email, password, role, created_at, updated_at
                FROM users 
                WHERE email = $1
        `

        var user models.User
        err := r.db.QueryRow(query, email).Scan(&amp;user.ID, &amp;user.FirstName, &amp;user.LastName, &amp;user.Email, &amp;user.Password, &amp;user.Role, &amp;user.CreatedAt, &amp;user.UpdatedAt)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("repository_user: getByEmail - query error: ", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (r *UserRepository) Update(id string, req models.UpdateUser) (*models.User, error) <span class="cov8" title="1">{
        query := `
                UPDATE users SET 
                        first_name = $1,
                        last_name = $2,
                        role = $3,
                        updated_at = $4
                WHERE id = $5
                RETURNING id, first_name, last_name, email, role, created_at, updated_at
        `

        var input models.User
        err := r.db.QueryRow(query, req.FirstName, req.LastName, req.Role, time.Now(), id).
                Scan(&amp;input.ID, &amp;input.FirstName, &amp;input.LastName, &amp;input.Email, &amp;input.Role, &amp;input.CreatedAt, &amp;input.UpdatedAt)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("repository_user: update - query error: ", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;input, nil</span>
}

func (r *UserRepository) Delete(id string) error <span class="cov8" title="1">{
        query := `DELETE FROM users WHERE id = $1`

        _, err := r.db.Exec(query, id)
        if err != nil </span><span class="cov8" title="1">{
                log.Println("repository_user: delete - exec error: ", err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package repository

import (
        "time"

        models "github.com/asliddinberdiev/medium_clone/models"
        "github.com/jmoiron/sqlx"
        "github.com/redis/go-redis/v9"
)

type User interface {
        Create(user models.User) (*models.User, error)
        GetAll() ([]*models.User, error)
        GetByID(id string) (*models.User, error)
        GetByEmail(email string) (*models.User, error)
        Update(id string, req models.UpdateUser) (*models.User, error)
        Delete(id string) error
}

type Auth interface {
        AddBlack(tokenID, token string, exp time.Duration) error
        GetBlackToken(tokenID string) (string, error)
}

type Repository struct {
        User
        Auth
}

func NewRepository(db *sqlx.DB, rdb *redis.Client) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                User: NewUserRepository(db),
                Auth: NewAuthRepository(db, rdb),
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package server

import (
        "context"
        "net/http"
        "time"
)

type Server struct {
        httpServer *http.Server
}

func (s *Server) Run(port string, handler http.Handler) error <span class="cov0" title="0">{
        s.httpServer = &amp;http.Server{
                Addr:           ":" + port,
                Handler:        handler,
                MaxHeaderBytes: 1 &lt;&lt; 20, // 1 MB
                ReadTimeout:    10 * time.Second,
                WriteTimeout:   10 * time.Second,
        }

        return s.httpServer.ListenAndServe()
}</span>

func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        return s.httpServer.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "time"

        "github.com/asliddinberdiev/medium_clone/config"
        models "github.com/asliddinberdiev/medium_clone/models"
        "github.com/asliddinberdiev/medium_clone/repository"
)

type User interface {
        Create(user models.UserCreate) (*models.User, error)
        GetAll() ([]*models.User, error)
        GetByID(id string) (*models.User, error)
        GetByEmail(email string) (*models.User, error)
        Update(id string, user models.UpdateUser) (*models.User, error)
        Delete(id string) error
}

type Auth interface {
        AddBlack(tokenID, token string, exp time.Duration) error
        HasBlackToken(tokenID string) bool
}

type Token interface {
        AccessTokenGenerate(userID string) (string, error)
        RefreshTokenGenerate(userID string) (string, error)
        Parse(tokenString string) (map[string]interface{}, error)
}

type Service struct {
        User
        Auth
        Token
}

func NewService(repo *repository.Repository, cfg config.App) *Service <span class="cov0" title="0">{
        return &amp;Service{
                User:  NewUserService(repo.User),
                Auth:  NewAuthService(repo.Auth),
                Token: NewTokenService(cfg),
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "log"
        "time"

        "github.com/asliddinberdiev/medium_clone/repository"
)

type AuthService struct {
        repo repository.Auth
}

func NewAuthService(repo repository.Auth) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{repo: repo}
}</span>

func (s *AuthService) AddBlack(tokenID, token string, exp time.Duration) error <span class="cov0" title="0">{
        return s.repo.AddBlack(tokenID, token, exp)
}</span>

func (s *AuthService) HasBlackToken(tokenID string) bool <span class="cov0" title="0">{
        _, err := s.repo.GetBlackToken(tokenID)
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">log.Println("service_auth: HasBlackToken - repo err: ", err)
        return true</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "fmt"
        "io"
        "log"
        "os"
        "path"
        "time"

        "github.com/gin-gonic/gin"
)

func LoggerWrite() io.Writer <span class="cov0" title="0">{
        _ = os.Mkdir("logs", 0770)

        logFilePath := path.Join("logs/", "access.log")

        logFile, err := os.OpenFile(logFilePath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0660)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_logger:  write - open file error: ", err)
        }</span>
        <span class="cov0" title="0">return io.MultiWriter(logFile, os.Stdout)</span>
}

func CustomLogger(out io.Writer) gin.HandlerFunc <span class="cov0" title="0">{
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                ctx.Next()

                end := time.Now()
                latency := end.Sub(start)

                clientIP := ctx.ClientIP()

                method := ctx.Request.Method
                path := ctx.Request.URL.Path

                statusCode := ctx.Writer.Status()

                formattedStart := start.Format("2006-01-02 15:04:05")

                logLine := fmt.Sprintf("%s | %s | %d | %v | %s  %s\n", formattedStart, clientIP, statusCode, latency, method, path)
                _, _ = out.Write([]byte(logLine))
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "errors"
        "log"
        "strconv"
        "strings"
        "time"

        "github.com/asliddinberdiev/medium_clone/config"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

type TokenService struct {
        cfg config.App
}

func NewTokenService(cfg config.App) *TokenService <span class="cov0" title="0">{
        return &amp;TokenService{cfg: cfg}
}</span>

func generate(userID, tokenType, sekretKey string, expireTime time.Duration) (string, error) <span class="cov0" title="0">{
        claims := jwt.MapClaims{
                "id":   userID,
                "type": tokenType,
                "iat":  time.Now().Unix(),
                "exp":  time.Now().Add(expireTime).Unix(),
                "jti":  uuid.New().String(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        signedToken, err := token.SignedString([]byte(sekretKey))
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_token:  generate - signedString error: ", err)
                return "", err
        }</span>

        <span class="cov0" title="0">return signedToken, nil</span>
}

func (s *TokenService) AccessTokenGenerate(userID string) (string, error) <span class="cov0" title="0">{
        accessTime, err := strconv.Atoi(s.cfg.AccessTime)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_token: accessGenerate - time error: ", err)
                return "", err
        }</span>
        <span class="cov0" title="0">return generate(userID, "access", s.cfg.TokenKey, time.Minute*time.Duration(accessTime))</span>
}

func (s *TokenService) RefreshTokenGenerate(userID string) (string, error) <span class="cov0" title="0">{
        refreshTime, err := strconv.Atoi(s.cfg.RefreshTime)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_token: refreshGenerate - time error: ", err)
                return "", err
        }</span>
        <span class="cov0" title="0">return generate(userID, "refresh", s.cfg.TokenKey, time.Hour*time.Duration(refreshTime))</span>
}

func (s *TokenService) Parse(tokenString string) (map[string]interface{}, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        log.Println("service_token: parse - method error")
                        return nil, errors.New("invalid token")
                }</span>
                <span class="cov0" title="0">return []byte(s.cfg.TokenKey), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "expired") </span><span class="cov0" title="0">{
                        log.Println("service_token: parse - token is expired: ", err)
                        return nil, errors.New("token is expired")
                }</span>
                <span class="cov0" title="0">log.Println("service_token: parse - error: ", err)
                return nil, errors.New("invalid token")</span>
        }

        <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                result := map[string]interface{}{
                        "id":   claims["id"],
                        "type": claims["type"],
                        "jti":  claims["jti"],
                }
                return result, nil
        }</span>

        <span class="cov0" title="0">log.Println("service_token: invalid")
        return nil, errors.New("invalid token")</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "database/sql"
        "log"

        models "github.com/asliddinberdiev/medium_clone/models"
        "github.com/asliddinberdiev/medium_clone/repository"
        "github.com/asliddinberdiev/medium_clone/utils"
        "github.com/google/uuid"
)

type UserService struct {
        repo repository.User
}

func NewUserService(repo repository.User) *UserService <span class="cov0" title="0">{
        return &amp;UserService{repo: repo}
}</span>

func (s *UserService) Create(user models.UserCreate) (*models.User, error) <span class="cov0" title="0">{
        _, err := s.repo.GetByEmail(user.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_user: create - checking db email: ", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">id, err := uuid.NewRandom()
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_user: create - uuid error: ", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">hashPassword, err := utils.GeneratePasswordHash(user.Password)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_user: create - password hashed error: ", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if user.Role == "" </span><span class="cov0" title="0">{
                user.Role = "user"
        }</span>

        <span class="cov0" title="0">newUser, err := s.repo.Create(models.User{ID: id.String(), FirstName: user.FirstName, LastName: user.LastName, Email: user.Email, Password: hashPassword, Role: user.Role})
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_user: create - repo: ", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return newUser, nil</span>
}

func (s *UserService) GetAll() ([]*models.User, error) <span class="cov0" title="0">{
        list, err := s.repo.GetAll()
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []*models.User{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return list, nil</span>
}

func (s *UserService) GetByID(id string) (*models.User, error) <span class="cov0" title="0">{
        user, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_user: getByID - repo: ", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (s *UserService) GetByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        user, err := s.repo.GetByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_user: getByEmail - repo: ", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (s *UserService) Update(id string, user models.UpdateUser) (*models.User, error) <span class="cov0" title="0">{
        dbUser, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        log.Println("service_user: update - not found dbUser")
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if user.FirstName == "" </span><span class="cov0" title="0">{
                user.FirstName = dbUser.FirstName
        }</span>
        <span class="cov0" title="0">if user.LastName == "" </span><span class="cov0" title="0">{
                user.LastName = dbUser.LastName
        }</span>
        <span class="cov0" title="0">if user.Role == "" </span><span class="cov0" title="0">{
                user.Role = dbUser.Role
        }</span>

        <span class="cov0" title="0">updateUser, err := s.repo.Update(id, user)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_user: update - repo error: ", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return updateUser, nil</span>
}

func (s *UserService) Delete(id string) error <span class="cov0" title="0">{
        err := s.repo.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("service_user: delete - repo error: ", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package utils

import (
        "github.com/asliddinberdiev/medium_clone/models"
        "github.com/gin-gonic/gin"
)

func Error(ctx *gin.Context, status int, message string) <span class="cov0" title="0">{
        ctx.AbortWithStatusJSON(status, models.ResponseStatus{Success: false, Message: message})
}</span>

func Data(ctx *gin.Context, status int, message string, data interface{}) <span class="cov0" title="0">{
        ctx.AbortWithStatusJSON(status, models.Response{
                Success: true,
                Message: message,
                Data:    data,
        })
}</span>

func List(ctx *gin.Context, status int, message string, limit, page uint, data interface{}) <span class="cov0" title="0">{
        ctx.AbortWithStatusJSON(status, models.ResponseList{
                Success: true,
                Message: message,
                Limit:   limit,
                Page:    page,
                Data:    data,
        })
}</span>

func Status(ctx *gin.Context, status int, message string) <span class="cov0" title="0">{
        ctx.AbortWithStatusJSON(status, models.ResponseStatus{Success: true, Message: message})
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package utils

import (
        "golang.org/x/crypto/bcrypt"
)

func GeneratePasswordHash(password string) (string, error) <span class="cov0" title="0">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(hashedPassword), nil</span>
}

func CheckPassword(hashPassword, password string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hashPassword), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package utils

import "strings"

func HasStringKey(text, key string) bool <span class="cov0" title="0">{
        return strings.Contains(text, key)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
